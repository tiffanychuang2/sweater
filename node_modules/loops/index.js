/* Copyright (c) 2011 Jamie Barnes
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var _for = function(init, test, incr, action, callback) {    
    var err;
    if (init === undefined) err = new Error('for() missing parameter: init');
    else if (test === undefined) err = new Error('for() missing parameter: test');
    else if (incr === undefined) err = new Error('for() missing parameter: incr');
    else if (action === undefined) err = new Error('for() missing parameter: action');
    else if (action.constructor !== Function) err = new Error('for() invalid parameter: action - expected Function');

    var val = init.constructor === Function ? init() : init;
    
    var func = function(v, t, i) { return function() {
        var testResult = !err && t.constructor === Function ? !!t(v)            // if function-based, return value determines whether loop continues
                               : t.constructor === v.constructor ? (v < t)      // if value-based, loop continues if truth value is greater than value (e.g. for (i = 1; i < 5; i++)
                               : !!t;                                           // if value and test are not the same type, loop continues if test is truthy
        
        if (!err && !!testResult) {
            try { action(v); }                                                  // run the action supplying the current value, v
            catch(e) { err = e; }
            
            if (!err) {
                var nextVal = (i.constructor === Function) ? i(v) : (v + i);    // apply increment function, i(), to current value, v
                process.nextTick(func(nextVal, t, i));                          // queue up next iteration
            }
        }
        else if (callback !== undefined && callback.constructor === Function) {
            callback(err, v);                                                   // run the callback when the truth test fails, or an error has occurred
        }
    } };
    
    func(val, test, incr)();                                                    // run the loop, with the initial values
};
var _while = function(test, action, callback) {
    var err;
    if (test === undefined) err = new Error('while() missing parameter: test');
    else if (action === undefined) err = new Error('while() missing parameter: action');   
    else if (action.constructor !== Function) err = new Error('while() invalid parameter: action - expected Function');
    
    var func = function(t) { return function() {
        var testResult = !err && t.constructor === Function ? !!t()             // if function-based, return value determines whether loop continues
                               : !!t;                                           // otherwise, loop continues if value of test is truthy
                               
        if (!err && !!testResult) {
            try { action(); }                                                   // run the action
            catch(e) { err = e; }
            
            if (!err) process.nextTick(func(t));                                // queue up the next iteration
        }
        else if (callback !== undefined && callback.constructor === Function) {
            callback(err);                                                      // run the callback when the truth test fails, or an error has occurred
        }
    }; };
    
    func(test)();                                                               // run the loop, with the initial values
};
var _do = function(action, test, callback) {
    var err;
    if (action === undefined) err = new Error('do() missing parameter: action');   
    else if (action.constructor !== Function) err = new Error('do() invalid parameter: action - expected Function');
    else if (test === undefined) err = new Error('do() missing parameter: test');
    
    var func = function(t) { return function() {
        if (!err) {
            try { action(); }
            catch(e) { err = e; }
            
            var testResult = !err && t.constructor === Function ? !!t()         // if function-based, return value determines whether loop continues
                                   : !!t;                                       // otherwise, loop continues if value of test is truthy
                                   
            if (!!testResult) process.nextTick(func(t));                        // queue up the next iteration
            else if (callback !== undefined && callback.constructor === Function) {
                callback(err);                                                  // run the callback when the truth test fails, or an error has occurred
            }
        }
    }; };
    
    func(test)();
};

exports.for = _for;
exports.while = _while;
exports.do = _do;